
/**
 * use uuid to get instead of email
 *
 * @author Sun Rui
 * @date 2025-10-08
 * @version 1.3
 */

package sg.com.aori.controller;

import java.net.URI;
import java.util.Optional;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import jakarta.validation.Valid;
import sg.com.aori.interfaces.ICreateAccount;
import sg.com.aori.model.Customer;
import sg.com.aori.model.CustomerAddress;
import sg.com.aori.service.CustomerService;

/**
 * REST controller for the "Create Account" use case.
 * Endpoints focus on creating a Customer and (optionally) adding an initial
 * CustomerAddress.
 */
@CrossOrigin
@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    private final ICreateAccount createAccountService;

    private final CustomerService customerService;

    public CustomerController(ICreateAccount createAccountService, CustomerService customerService) {
        this.createAccountService = createAccountService;
        this.customerService = customerService;
    }

    /**
     * Create a new customer.
     *
     * param: customer Request body containing a fully-prepared Customer entity (id
     * auto-generated by entity).
     * return: 201 Created with the persisted Customer in body and Location header
     * pointing to /api/customers/{id}.
     * throws: IllegalArgumentException if input is invalid.
     */
    @PostMapping
    public ResponseEntity<Customer> createCustomer(@Valid @RequestBody Customer customer) {
        // Validate password is not blank for customer creation
        if (customer.getPassword() == null || customer.getPassword().isBlank()) {
            throw new IllegalArgumentException("Password is required for customer registration");
        }
        if (customer.getCustomerId() == null || customer.getCustomerId().isBlank()) {
            customer.setCustomerId(java.util.UUID.randomUUID().toString());
        }
        Customer saved = createAccountService.createCustomer(customer);
        return ResponseEntity
                .created(URI.create("/api/customers/" + saved.getCustomerId()))
                .body(saved);
    }

    /**
     * Get a customer by id from query parameter.
     *
     * param: customerId Customer primary key (String UUID).
     * return: 200 OK with Customer if found, otherwise 404 Not Found.
     */
    @GetMapping
    public ResponseEntity<Customer> getCustomerByIdQuery(@RequestParam("customerId") String customerId) {
        return buildCustomerResponse(customerService.findCustomerById(customerId));
    }

    /**
     * Add an initial address for the given customer.
     * If the customer has no default address yet, this address will be marked as
     * default.
     *
     * param: customerId The Customer primary key (String UUID) from the path.
     * param: address The address payload; its customerId will be enforced to match
     * path variable.
     * return: 201 Created with the persisted CustomerAddress in body and Location
     * header pointing to /api/customers/{id}/addresses.
     * throws: IllegalArgumentException if input is invalid.
     */
    @PostMapping("/{customerId}/addresses")
    public ResponseEntity<CustomerAddress> addInitialAddress(@PathVariable String customerId,
            @Valid @RequestBody CustomerAddress address) {
        // 以路径变量为准，避免与 body 内不一致
        address.setCustomerId(customerId);
        CustomerAddress saved = createAccountService.addInitialAddress(address);
        return ResponseEntity
                .created(URI.create("/api/customers/" + customerId + "/addresses"))
                .body(saved);
    }

    @GetMapping("/{customerId}")
    public ResponseEntity<Customer> getCustomerById(@PathVariable String customerId) {
        return buildCustomerResponse(customerService.findCustomerById(customerId));
    }

    private ResponseEntity<Customer> buildCustomerResponse(Optional<Customer> customer) {
        return customer.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

}
