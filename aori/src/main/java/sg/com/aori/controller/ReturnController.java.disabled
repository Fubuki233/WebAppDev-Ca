package sg.com.aori.controller;

import sg.com.aori.model.Returns;
import sg.com.aori.service.ReturnService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.validation.annotation.Validated;
import jakarta.validation.Valid;

/*
 * * @author Simon Lei
 * * @date 2025-10-14
 * * @version 1.1
 * Update on the ReturnController about validations and error handling.
 */
@RestController
@RequestMapping("/api/returns")
@Validated
public class ReturnController {

    private final ReturnService returnService;

    public ReturnController(ReturnService returnService) {
        this.returnService = returnService;
    }

    // Step 3 & 4: Receives the Returns entity directly from the JSON body.
    @PostMapping("/request")
    public ResponseEntity<String> initiateReturn(
            @RequestBody @Validated(Returns.OnCreate.class) @Valid Returns returns,
            @RequestHeader("X-User-Id") String userId) {

        try {
            // NOTE: We rely on the request JSON body to contain 'orderId', 'productId', and
            // 'requestReason'.

            // Delegate the entire entity to the service
            String confirmationMessage = returnService.processReturnRequest(returns, userId);

            // Step 6 & 7 (Return Confirmation/Instructions)
            return ResponseEntity.ok(confirmationMessage);

        } catch (IllegalArgumentException e) {
            // Catches validation or "not found" errors
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (RuntimeException e) {
            // Catches failure during the refund process (Step 11)
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Processing failed: " + e.getMessage());
        }
    }
}